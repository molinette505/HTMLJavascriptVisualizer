// @ts-nocheck
export const TokenType={KEYWORD:'KEYWORD',IDENTIFIER:'IDENTIFIER',NUMBER:'NUMBER',STRING:'STRING',OPERATOR:'OPERATOR',PUNCTUATION:'PUNCTUATION',COMMENT:'COMMENT',EOF:'EOF',BOOLEAN:'BOOLEAN'};
export const KEYWORDS=['let','const','var','if','else','while','for','do','function','return','switch','case','break','default','new'];
export class Token{constructor(type,value,line,id=null){this.type=type;this.value=value;this.line=line;this.id=id||`tok-${Math.random().toString(36).substr(2,9)}`;}}
export class Lexer{constructor(input){this.input=input;this.pos=0;this.line=1;this.tokens=[];}tokenize(){while(this.pos<this.input.length){const char=this.input[this.pos];const next=this.input[this.pos+1]||'';if(/\s/.test(char)){if(char==='\n')this.line++;this.tokens.push(new Token('WHITESPACE',char,this.line));this.pos++;continue;}if(char==='/'&&next==='/'){let val='//';this.pos+=2;while(this.pos<this.input.length&&this.input[this.pos]!=='\n'){val+=this.input[this.pos++];}this.tokens.push(new Token(TokenType.COMMENT,val,this.line));continue;}if(char==='/'&&next==='*'){let val='/*';this.pos+=2;while(this.pos<this.input.length-1&&!(this.input[this.pos]==='*'&&this.input[this.pos+1]==='/')){if(this.input[this.pos]==='\n')this.line++;val+=this.input[this.pos++];}if(this.pos<this.input.length-1){val+='*/';this.pos+=2;}this.tokens.push(new Token(TokenType.COMMENT,val,this.line));continue;}if(/[0-9]/.test(char)){let val='';while(this.pos<this.input.length&&/[0-9.]/.test(this.input[this.pos])){val+=this.input[this.pos++];}this.tokens.push(new Token(TokenType.NUMBER,parseFloat(val),this.line));continue;}if(/[a-zA-Z_$]/.test(char)){let val='';while(this.pos<this.input.length&&/[a-zA-Z0-9_$]/.test(this.input[this.pos])){val+=this.input[this.pos++];}if(KEYWORDS.includes(val))this.tokens.push(new Token(TokenType.KEYWORD,val,this.line));else if(['true','false'].includes(val))this.tokens.push(new Token(TokenType.BOOLEAN,val==='true',this.line));else this.tokens.push(new Token(TokenType.IDENTIFIER,val,this.line));continue;}if(char==='"'||char==="'"){let val=char;const quote=char;this.pos++;while(this.pos<this.input.length&&this.input[this.pos]!==quote){if(this.input[this.pos]==='\n')this.line++;val+=this.input[this.pos++];}if(this.pos<this.input.length){val+=this.input[this.pos];this.pos++;}this.tokens.push(new Token(TokenType.STRING,val,this.line));continue;}if(char==='`'){let val='`';this.pos++;while(this.pos<this.input.length){const c=this.input[this.pos];if(c==='\\'){val+=c;this.pos++;if(this.pos<this.input.length){if(this.input[this.pos]==='\n')this.line++;val+=this.input[this.pos];this.pos++;}continue;}if(c==='`'){val+=c;this.pos++;break;}if(c==='\n')this.line++;val+=c;this.pos++;}this.tokens.push(new Token(TokenType.STRING,val,this.line));continue;}if(['=','+','-','*','/','>','<','!','&','|','%'].includes(char)){const nextNext=this.input[this.pos+2]||'';if(['===','!=='].includes(char+next+nextNext)){this.tokens.push(new Token(TokenType.OPERATOR,char+next+nextNext,this.line));this.pos+=3;continue;}if(['==','!=','<=','>=','&&','||','++','--','+=','-=','*=','/=','=>'].includes(char+next)){this.tokens.push(new Token(TokenType.OPERATOR,char+next,this.line));this.pos+=2;}else{this.tokens.push(new Token(TokenType.OPERATOR,char,this.line));this.pos++;}continue;}if(['(',')','{','}','[',']',';',',',':','.'].includes(char)){this.tokens.push(new Token(TokenType.PUNCTUATION,char,this.line));this.pos++;continue;}this.tokens.push(new Token('UNKNOWN',char,this.line));this.pos++;}return this.tokens;}}
export class ASTNode{constructor(line){this.line=line;this.domIds=[];}}
export class Program extends ASTNode{constructor(){super(0);this.body=[];}}
export class VarDecl extends ASTNode{constructor(kind,name,init,line){super(line);this.kind=kind;this.name=name;this.init=init;}}
export class MultiVarDecl extends ASTNode{constructor(decls,line){super(line);this.decls=decls;}}
export class FunctionDecl extends ASTNode{constructor(name,params,body,line){super(line);this.name=name;this.params=params;this.body=body;}}
export class Assignment extends ASTNode{constructor(left,value,line){super(line);this.left=left;this.value=value;}}
export class BinaryExpr extends ASTNode{constructor(left,op,right,line){super(line);this.left=left;this.op=op;this.right=right;}}
export class CallExpr extends ASTNode{constructor(callee,args,line){super(line);this.callee=callee;this.args=args;}}
export class IfStmt extends ASTNode{constructor(test,consequent,alternate,line){super(line);this.test=test;this.consequent=consequent;this.alternate=alternate;}}
export class WhileStmt extends ASTNode{constructor(test,body,line){super(line);this.test=test;this.body=body;}}
export class DoWhileStmt extends ASTNode{constructor(body,test,line){super(line);this.body=body;this.test=test;}}
export class ForStmt extends ASTNode{constructor(init,test,update,body,line){super(line);this.init=init;this.test=test;this.update=update;this.body=body;}}
export class SwitchStmt extends ASTNode{constructor(discriminant,cases,line){super(line);this.discriminant=discriminant;this.cases=cases;}}
export class SwitchCase extends ASTNode{constructor(test,consequent,line){super(line);this.test=test;this.consequent=consequent;}}
export class BreakStmt extends ASTNode{constructor(line){super(line);}}
export class BlockStmt extends ASTNode{constructor(body,line){super(line);this.body=body;}}
export class ReturnStmt extends ASTNode{constructor(arg,line){super(line);this.argument=arg;}}
export class Literal extends ASTNode{constructor(value,line,isTemplate=false){super(line);this.value=value;this.isTemplate=isTemplate;}}
export class Identifier extends ASTNode{constructor(name,line){super(line);this.name=name;}}
export class UpdateExpr extends ASTNode{constructor(op,arg,prefix,line){super(line);this.op=op;this.arg=arg;this.prefix=prefix;}}
export class MemberExpr extends ASTNode{constructor(object,property,computed,line){super(line);this.object=object;this.property=property;this.computed=computed;}}
export class ArrayLiteral extends ASTNode{constructor(elements,line){super(line);this.elements=elements;}}
export class NewExpr extends ASTNode{constructor(callee,args,line){super(line);this.callee=callee;this.args=args;}}
export class ArrowFunctionExpr extends ASTNode{constructor(params,body,line){super(line);this.params=params;this.body=body;}}
export class FunctionExpression extends ASTNode{constructor(name,params,body,line){super(line);this.name=name;this.params=params;this.body=body;}}
export class ArgumentsNode extends ASTNode{constructor(args,line){super(line);this.args=args;}}
export class UnaryExpr extends ASTNode{constructor(op,arg,line){super(line);this.op=op;this.arg=arg;}}

export class Parser{constructor(tokens){this.tokens=tokens.filter(t=>t.type!=='WHITESPACE'&&t.type!=='COMMENT');this.current=0;}parse(){const program=new Program();while(!this.isAtEnd()){program.body.push(this.statement());}return program;}statement(){if(this.match(TokenType.KEYWORD)){const val=this.previous().value;if(['let','const','var'].includes(val))return this.varDecl();if(val==='function')return this.funcDecl();if(val==='if')return this.ifStmt();if(val==='while')return this.whileStmt();if(val==='do')return this.doWhileStmt();if(val==='for')return this.forStmt();if(val==='switch')return this.switchStmt();if(val==='break')return this.breakStmt();if(val==='return')return this.returnStmt();this.current--;}if(this.match(TokenType.PUNCTUATION,'{'))return this.block();return this.exprStmt();}block(){const line=this.previous().line;const stmts=[];while(!this.check(TokenType.PUNCTUATION,'}')&&!this.isAtEnd())stmts.push(this.statement());this.consume(TokenType.PUNCTUATION,'}');return new BlockStmt(stmts,line);}varDecl(){const kind=this.previous().value;const decls=[];do{const nameToken=this.consume(TokenType.IDENTIFIER);let init=null;if(this.match(TokenType.OPERATOR,'=')){init=this.expression();}const node=new VarDecl(kind,nameToken.value,init,nameToken.line);node.nameTokenId=nameToken.id;decls.push(node);}while(this.match(TokenType.PUNCTUATION,','));if(this.check(TokenType.PUNCTUATION,';')){this.consume(TokenType.PUNCTUATION,';');}if(decls.length===1)return decls[0];return new MultiVarDecl(decls,decls[0].line);}funcDecl(){const nameToken=this.consume(TokenType.IDENTIFIER);this.consume(TokenType.PUNCTUATION,'(');const params=[];if(!this.check(TokenType.PUNCTUATION,')')){do{params.push({name:this.consume(TokenType.IDENTIFIER).value,id:this.previous().id});}while(this.match(TokenType.PUNCTUATION,','));}this.consume(TokenType.PUNCTUATION,')');this.consume(TokenType.PUNCTUATION,'{');const body=this.block();return new FunctionDecl(nameToken.value,params,body,nameToken.line);}ifStmt(){const line=this.previous().line;this.consume(TokenType.PUNCTUATION,'(');const test=this.expression();this.consume(TokenType.PUNCTUATION,')');const cons=this.statement();let alt=null;if(this.match(TokenType.KEYWORD,'else'))alt=this.statement();return new IfStmt(test,cons,alt,line);}whileStmt(){const line=this.previous().line;this.consume(TokenType.PUNCTUATION,'(');const test=this.expression();this.consume(TokenType.PUNCTUATION,')');const body=this.statement();return new WhileStmt(test,body,line);}doWhileStmt(){const line=this.previous().line;const body=this.statement();this.consume(TokenType.KEYWORD,'while');this.consume(TokenType.PUNCTUATION,'(');const test=this.expression();this.consume(TokenType.PUNCTUATION,')');if(this.check(TokenType.PUNCTUATION,';')){this.consume(TokenType.PUNCTUATION,';');}return new DoWhileStmt(body,test,line);}forStmt(){const line=this.previous().line;this.consume(TokenType.PUNCTUATION,'(');let init=null;if(!this.check(TokenType.PUNCTUATION,';')){if(this.match(TokenType.KEYWORD,['let','const','var'])){init=this.varDecl();}else{init=this.exprStmt();}}else{this.consume(TokenType.PUNCTUATION,';');}let test=null;if(!this.check(TokenType.PUNCTUATION,';'))test=this.expression();this.consume(TokenType.PUNCTUATION,';');let update=null;if(!this.check(TokenType.PUNCTUATION,')'))update=this.expression();this.consume(TokenType.PUNCTUATION,')');const body=this.statement();return new ForStmt(init,test,update,body,line);}breakStmt(){const line=this.previous().line;if(this.check(TokenType.PUNCTUATION,';')){this.consume(TokenType.PUNCTUATION,';');}return new BreakStmt(line);}switchStmt(){const line=this.previous().line;this.consume(TokenType.PUNCTUATION,'(');const disc=this.expression();this.consume(TokenType.PUNCTUATION,')');this.consume(TokenType.PUNCTUATION,'{');const cases=[];while(!this.check(TokenType.PUNCTUATION,'}')&&!this.isAtEnd()){if(this.match(TokenType.KEYWORD,'case')){const cLine=this.previous().line;const test=this.expression();this.consume(TokenType.PUNCTUATION,':');const cons=[];while(!this.check(TokenType.KEYWORD,['case','default'])&&!this.check(TokenType.PUNCTUATION,'}')&&!this.isAtEnd())cons.push(this.statement());cases.push(new SwitchCase(test,cons,cLine));}else if(this.match(TokenType.KEYWORD,'default')){const cLine=this.previous().line;this.consume(TokenType.PUNCTUATION,':');const cons=[];while(!this.check(TokenType.KEYWORD,['case','default'])&&!this.check(TokenType.PUNCTUATION,'}')&&!this.isAtEnd())cons.push(this.statement());cases.push(new SwitchCase(null,cons,cLine));}}this.consume(TokenType.PUNCTUATION,'}');return new SwitchStmt(disc,cases,line);}returnStmt(){const keyword=this.previous();const line=keyword.line;let val=null;let domIds=[keyword.id];if(!this.check(TokenType.PUNCTUATION,';')&&!this.check(TokenType.PUNCTUATION,'}')){val=this.expression();domIds.push(...val.domIds);}if(this.check(TokenType.PUNCTUATION,';')){const semi=this.consume(TokenType.PUNCTUATION,';');domIds.push(semi.id);}const node=new ReturnStmt(val,line);node.domIds=domIds;return node;}exprStmt(){const expr=this.expression();if(this.check(TokenType.PUNCTUATION,';')){this.consume(TokenType.PUNCTUATION,';');}return expr;}expression(){return this.assignment();}assignment(){const expr=this.arrow();if(this.match(TokenType.OPERATOR,['=','+=','-=','*=','/='])){const opToken=this.previous();const value=this.assignment();if(expr instanceof Identifier||expr instanceof MemberExpr){if(opToken.value==='='){const node=new Assignment(expr,value,expr.line);node.targetTokenId=(expr instanceof Identifier)?expr.domIds[0]:null;return node;}else{const binOp=opToken.value.charAt(0);const binExpr=new BinaryExpr(expr,binOp,value,expr.line);binExpr.domIds=[...expr.domIds,opToken.id,...value.domIds];const node=new Assignment(expr,binExpr,expr.line);node.targetTokenId=(expr instanceof Identifier)?expr.domIds[0]:null;return node;}}throw new Error("Invalid assignment target");}return expr;}arrow(){let expr=this.logicalOR();if(this.match(TokenType.OPERATOR,'=>')){const arrow=this.previous();const params=[];if(expr instanceof Identifier){params.push({name:expr.name,id:expr.tokenId||expr.domIds[0]});}else if(expr instanceof ArgumentsNode){expr.args.forEach(arg=>{if(arg instanceof Identifier){params.push({name:arg.name,id:arg.tokenId||arg.domIds[0]});}else throw new Error("Paramètre de fonction fléchée invalide");});}else if(expr instanceof Literal&&expr.value===undefined){}else{throw new Error("Syntaxe de fonction fléchée invalide");}let body;if(this.match(TokenType.PUNCTUATION,'{')){body=this.block();}else{body=this.expression();}const node=new ArrowFunctionExpr(params,body,expr.line);node.domIds=[...expr.domIds,arrow.id];return node;}return expr;}logicalOR(){return this.binary(['||'],this.logicalAND.bind(this));}logicalAND(){return this.binary(['&&'],this.equality.bind(this));}equality(){return this.binary(['==','!=','===','!=='],this.relational.bind(this));}relational(){return this.binary(['>','<','>=','<='],this.additive.bind(this));}additive(){return this.binary(['+','-'],this.multiplicative.bind(this));}multiplicative(){return this.binary(['*','/','%'],this.unary.bind(this));}unary(){if(this.match(TokenType.KEYWORD,'new')){const line=this.previous().line;const callee=this.primary();this.consume(TokenType.PUNCTUATION,'(');const args=[];if(!this.check(TokenType.PUNCTUATION,')')){do{args.push(this.expression());}while(this.match(TokenType.PUNCTUATION,','));}this.consume(TokenType.PUNCTUATION,')');return new NewExpr(callee,args,line);}if(this.match(TokenType.OPERATOR,['++','--'])){const op=this.previous();const right=this.unary();const node=new UpdateExpr(op.value,right,true,op.line);node.domIds=[op.id,...right.domIds];return node;}if(this.match(TokenType.OPERATOR,['!','-','+'])){const op=this.previous();const right=this.unary();const node=new UnaryExpr(op.value,right,op.line);node.domIds=[op.id,...right.domIds];return node;}return this.postfix();}postfix(){let expr=this.call();if(this.match(TokenType.OPERATOR,['++','--'])){const op=this.previous();const node=new UpdateExpr(op.value,expr,false,op.line);node.domIds=[...expr.domIds,op.id];expr=node;}return expr;}binary(ops,nextFn){let left=nextFn();while(this.match(TokenType.OPERATOR,ops)){const opToken=this.previous();const right=nextFn();const node=new BinaryExpr(left,opToken.value,right,left.line);node.domIds=[...left.domIds,opToken.id,...right.domIds];left=node;}return left;}call(){let expr=this.primary();while(true){if(this.match(TokenType.PUNCTUATION,'(')){const openParen=this.previous();const args=[];let domIds=[...expr.domIds,openParen.id];if(!this.check(TokenType.PUNCTUATION,')')){do{if(args.length>0){const comma=this.consume(TokenType.PUNCTUATION,',');domIds.push(comma.id);}const arg=this.expression();args.push(arg);domIds.push(...arg.domIds);}while(this.check(TokenType.PUNCTUATION,','));}const closeParen=this.consume(TokenType.PUNCTUATION,')');domIds.push(closeParen.id);const node=new CallExpr(expr,args,expr.line);node.domIds=domIds;expr=node;}else if(this.match(TokenType.PUNCTUATION,'.')){const dot=this.previous();const id=this.consume(TokenType.IDENTIFIER);if(expr instanceof Identifier&&(expr.name==='Math'||expr.name==='console')){const oldId=expr.domIds;expr=new Identifier(`${expr.name}.${id.value}`,expr.line);expr.domIds=[...oldId,dot.id,id.id];}else{const obj=expr;expr=new MemberExpr(obj,new Literal(id.value,id.line),false,id.line);expr.domIds=[...obj.domIds,dot.id,id.id];}}else if(this.match(TokenType.PUNCTUATION,'[')){const openBracket=this.previous();const prop=this.expression();const closeBracket=this.consume(TokenType.PUNCTUATION,']');expr=new MemberExpr(expr,prop,true,openBracket.line);expr.domIds=[...expr.object.domIds,openBracket.id,...prop.domIds,closeBracket.id];}else{break;}}return expr;}primary(){if(this.match(TokenType.KEYWORD,'function')){const line=this.previous().line;let name=null;if(this.check(TokenType.IDENTIFIER)){name=this.consume(TokenType.IDENTIFIER).value;}this.consume(TokenType.PUNCTUATION,'(');const params=[];if(!this.check(TokenType.PUNCTUATION,')')){do{params.push({name:this.consume(TokenType.IDENTIFIER).value,id:this.previous().id});}while(this.match(TokenType.PUNCTUATION,','));}this.consume(TokenType.PUNCTUATION,')');this.consume(TokenType.PUNCTUATION,'{');const body=this.block();return new FunctionExpression(name,params,body,line);}if(this.match(TokenType.PUNCTUATION,'[')){const openBracket=this.previous();const elements=[];const domIds=[openBracket.id];if(!this.check(TokenType.PUNCTUATION,']')){do{if(elements.length>0){const comma=this.consume(TokenType.PUNCTUATION,',');domIds.push(comma.id);}const el=this.expression();elements.push(el);domIds.push(...el.domIds);}while(this.check(TokenType.PUNCTUATION,','));}const closeBracket=this.consume(TokenType.PUNCTUATION,']');domIds.push(closeBracket.id);const node=new ArrayLiteral(elements,openBracket.line);node.domIds=domIds;return node;}if(this.match(TokenType.NUMBER)){const t=this.previous();const node=new Literal(t.value,t.line);node.domIds=[t.id];return node;}if(this.match(TokenType.STRING)){const t=this.previous();const cleanVal=t.value.substring(1,t.value.length-1);const node=new Literal(cleanVal,t.line,t.value.startsWith('`'));node.domIds=[t.id];return node;}if(this.match(TokenType.BOOLEAN)){const t=this.previous();const node=new Literal(t.value,t.line);node.domIds=[t.id];return node;}if(this.match(TokenType.IDENTIFIER)){const t=this.previous();const node=new Identifier(t.value,t.line);node.domIds=[t.id];node.tokenId=t.id;return node;}if(this.match(TokenType.PUNCTUATION,'(')){const openParen=this.previous();if(this.match(TokenType.PUNCTUATION,')')){const node=new Literal(undefined,openParen.line);node.domIds=[openParen.id,this.previous().id];return node;}const args=[];let domIds=[openParen.id];if(!this.check(TokenType.PUNCTUATION,')')){const expr=this.expression();args.push(expr);domIds.push(...expr.domIds);while(this.match(TokenType.PUNCTUATION,',')){const c=this.previous();domIds.push(c.id);const nextExpr=this.expression();args.push(nextExpr);domIds.push(...nextExpr.domIds);}}const closeParen=this.consume(TokenType.PUNCTUATION,')');domIds.push(closeParen.id);if(args.length>1){const node=new ArgumentsNode(args,openParen.line);node.domIds=domIds;return node;}else{const expr=args[0];expr.domIds=domIds;return expr;}}throw new Error("Unexpected token");}match(type,val){if(this.check(type,val)){this.advance();return true;}return false;}check(type,val){if(this.isAtEnd())return false;const t=this.peek();if(Array.isArray(val))return t.type===type&&val.includes(t.value);if(val)return t.type===type&&t.value===val;return t.type===type;}consume(type,val){if(this.check(type,val))return this.advance();const found=this.isAtEnd()?"EOF":`${this.peek().type}(${this.peek().value})`;throw new Error(`Attendu: ${type}${val?' '+val:''}, trouvé: ${found}`);}advance(){if(!this.isAtEnd())this.current++;return this.previous();}peek(){return this.tokens[this.current];}previous(){return this.tokens[this.current-1];}isAtEnd(){return this.current>=this.tokens.length;}}
